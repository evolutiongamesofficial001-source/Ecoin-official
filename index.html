const axios = require('axios');
const cors = require('cors');
const crypto = require('crypto');

const firebaseUrl = 'https://ecoin-b7697-default-rtdb.firebaseio.com/.json';
const firebaseUrl1 = 'https://ecoin-b7697-default-rtdb.firebaseio.com';
const transactionHistoryUrl = 'https://transfereciaecoin-default-rtdb.firebaseio.com';

const corsHandler = cors({
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type'],
});

function generateTransactionId() {
  return crypto.randomBytes(16).toString('hex');
}

function verifyPrivateKey(privateKey, storedHash) {
  try {
    const [salt, originalHash] = storedHash.split(':');
    const hash = crypto.pbkdf2Sync(privateKey, salt, 100000, 128, 'sha512').toString('hex');
    return hash === originalHash;
  } catch {
    return false;
  }
}

async function getTransactionHistory() {
  try {
    const res = await axios.get(transactionHistoryUrl + '.json');
    return res.data || {};
  } catch {
    return {};
  }
}

async function calculateDynamicFee(amount) {
  const txs = await getTransactionHistory();
  const count = Object.keys(txs).length;
  let fee = 0.00001 + (count * 0.000001) + (amount * 0.000001);
  if (fee > 0.00003) fee = 0.00003;
  return Number(fee.toFixed(5));
}

async function saveTransaction(tx) {
  try {
    await axios.put(`${transactionHistoryUrl}/${tx.id}.json`, tx);
    return true;
  } catch {
    return false;
  }
}

function normalize(v) {
  return typeof v === 'string' ? v.replace(',', '.') : v;
}

module.exports = async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') return res.status(200).end();

  corsHandler(req, res, async () => {
    try {
      if (req.method === 'GET' && req.query.fee !== undefined) {
        const fee = await calculateDynamicFee(1);
        return res.status(200).json({ fee });
      }

      if (req.method === 'GET') {
        const txs = await getTransactionHistory();
        return res.status(200).json(txs);
      }

      if (req.method === 'POST') {
        const { private_key, destination_address, amount } = req.body;
        if (!private_key || !destination_address || !amount) {
          return res.status(400).json({ success: false, error: 'Missing parameters' });
        }

        const value = parseFloat(normalize(amount));
        if (isNaN(value) || value <= 0) {
          return res.status(400).json({ success: false, error: 'Invalid amount' });
        }

        const fee = await calculateDynamicFee(value);
        const total = Number((value + fee).toFixed(5));

        const { data: accounts } = await axios.get(firebaseUrl);
        if (!accounts) return res.status(404).json({ success: false, error: 'No wallets' });

        let senderId, sender, receiverId, receiver;

        for (const [id, acc] of Object.entries(accounts)) {
          if (verifyPrivateKey(private_key, acc.key_hash)) {
            senderId = id;
            sender = acc;
          }
          if (acc.address === destination_address) {
            receiverId = id;
            receiver = acc;
          }
        }

        if (!sender) return res.status(404).json({ success: false, error: 'Invalid private key' });
        if (!receiver) return res.status(404).json({ success: false, error: 'Destination not found' });

        const senderBalance = parseFloat(normalize(sender.balance));
        if (senderBalance < total) return res.status(400).json({ success: false, error: 'Insufficient balance' });

        const newSender = (senderBalance - total).toFixed(5);
        const newReceiver = (parseFloat(receiver.balance) + value).toFixed(5);

        await axios.patch(`${firebaseUrl1}/${senderId}.json`, { balance: newSender });
        await axios.patch(`${firebaseUrl1}/${receiverId}.json`, { balance: newReceiver });

        const tx = {
          id: generateTransactionId(),
          from: sender.address,
          to: receiver.address,
          amount: value.toFixed(5),
          fee,
          timestamp: new Date().toISOString(),
        };

        if (!(await saveTransaction(tx))) return res.status(500).json({ success: false, error: 'Tx save failed' });

        return res.status(200).json({
          success: true,
          transaction: tx,
          balances: { sender: newSender, receiver: newReceiver },
        });
      }

      return res.status(405).json({ error: 'Method not allowed' });
    } catch (e) {
      return res.status(500).json({ success: false, error: e.message });
    }
  });
};
